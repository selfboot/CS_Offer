网络本质上就是解决**多台计算机之间如何互相通信**这个问题，从最初的ARPANET(Advanced Research Projects Agency Network) 到现在的 TCP/IP，这个本质问题并没有变化，只是技术不断改进。

20世纪60年代以来，计算机网络得到了飞速增长。各大厂商为了在数据通信网络领域占据主导地位，纷纷推出了各自的网络架构体系和标准，如IBM公司的SNA，Apple公司的AppleTalk协议，以及广泛流行的TCP/IP协议。同时，各大厂商针对自己的协议生产出了不同的硬件和软件。由于多种协议的并存，使得网络变得越来越复杂；而且，厂商之间的网络设备大部分不能兼容，很难进行通信。

为了解决网络之间的兼容性问题，帮助各个厂商生产出可兼容的网络设备，国际标准化组织ISO于1984年提出了`OSI RM`（OpenSystem Interconnection Reference Model，开放式系统互联通信参考模型），OSI 参考模型很快成为计算机网络通信的基础模型。该体系结构定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性。

由于OSI模型和协议比较复杂，所以并没有得到广泛的应用。而TCP/IP(transfer control protocol/internet protocol,传输控制协议/网际协议)模型因其开放性和易用性在实践中得到了广泛的应用，TCP/IP协议栈也成为互联网的主流协议。

![TCP/IP][1]

更多内容参考 [OSI_TCP_IP](OSI_TCP_IP.md)

# 网络层

网络层(network layer)是实现互联网的最重要的一层。正是在网络层面上，各个局域网根据IP协议相互连接，最终构成覆盖全球的Internet。更高层的协议，无论是TCP还是UDP，必须通过网络层的IP数据包(datagram)来传递信息。

IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制--这被认为是上层协议--TCP或UDP要做的事情。

更多内容参考 [IP](IP.md)

## ICMP 协议

ICMP 是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递`控制消息`。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

ICMP基于IP协议，也就是说，一个ICMP包需要封装在IP包中，然后在互联网传送。ICMP是IP套装的必须部分，任何一个支持IP协议的计算机，都要同时实现ICMP。

ICMP传输的控制信息可以分为两大类：

* `错误(error)信息`：这一类信息可用来诊断网络故障。IP协议的工作方式是“Best Effort”，如果IP包没有被传送到目的地，或者IP包发生错误，IP协议本身不会做进一步的努力。但上游发送IP包的主机和接力的路由器并不知道下游发生了错误和故障，它们可能继续发送IP包。通过ICMP包，下游的路由器和主机可以将错误信息汇报给上游，从而让上游的路由器和主机进行调整。
* `咨询(Informational)信息`：比如某台计算机询问路径上的每个路由器都是谁，然后各个路由器同样用ICMP包回答。

ICMP包有Type, Code和Checksum三部分：

* 类型：指明该数据包属于什么类型（大分类），长度1个字节。
* 代码：指明数据包属于大类里面的哪个小类，长度1个字节。类型字段与代码字段共同决定ICMP数据包类型，以及后续字段含义。
* 校验和： 指明该数据包的校验和，长度2个字节。该校验和覆盖整个ICMP数据包。

ICMP数据包通过类型字段与代码字段来共同决定该数据包传达的控制信息。常见的ICMP包类型：

* 0（Echo Reply）：属于咨询信息，ping命令就是利用了该类型的ICMP包。 
* 3（Destination Unreachable）属于错误信息。如果一个路由器接收到一个IP包，不知道下一步往哪里发送，就会向出发主机发送该类型的ICMP包。
* 11（Time Exceeded）属于错误信息。IPv4中的Time to Live(TTL)会随着经过的路由器而递减，当这个区域值减为0时，就认为该IP包超时(Time Exceeded)。traceroute就利用了这种类型的ICMP包，它向目的地发送IP包，第一次的时候，将TTL设置为1，引发第一个路由器的Time Exceeded错误。这样，第一个路由器回复ICMP包，从而让出发主机知道途径的第一个路由器的信息。随后TTL被设置为2、3、4，...，直到到达目的主机。这样，沿途的每个路由器都会向出发主机发送ICMP包来汇报错误。traceroute将ICMP包的信息打印在屏幕上，就是接力路径的信息了。

## 地址解析协议（ARP）

首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。

当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP地址。

当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。

源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。`广播发送ARP请求，单播发送ARP响应`。

`RARP协议`：反向地址转换协议，允许局域网的物理机器从网关服务器的ARP表或者缓存上请求其IP地址。其因为较限于IP地址的运用以及其他的一些缺点，因此渐为更新的BOOTP或DHCP所取代。

工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系。当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。

# 传输层

## TCP 协议

TCP(Transmission Control Protocol)为应用程序之间提供面向连接的可靠的字节流服务。TCP为全双工协议，提供流控制机制，即允许接收方控制发送方的发送速度，此外还提供拥塞控制功能。

［[TCP 协议细节](http://www.nowcoder.com/questionTerminal/7aa912d4886e45759698dd074521c726)］  
［[滑动窗口协议](http://www.nowcoder.com/questionTerminal/3d9d35cc024840d2ae21929bcf868d53)］  
［[nagle算法](http://www.nowcoder.com/questionTerminal/787f0b432012420cb2918b7e1ca37ab2)］  
［[拥塞控制算法](http://www.nowcoder.com/questionTerminal/a2b95450f85c4855877a0c4f06c91a72)］  
［[状态转换流程](http://www.nowcoder.com/questionTerminal/246945f0e26541b89f4735c79e3f16a2)］  

详细内容参见 [TCP](TCP.md)

### 网络端口

TCP 服务器由发送端和接收端创建一种称为`套接字`的端点来获得，每个套接字有一个套接字编号（地址），该编号由主机的 IP 地址以及一个本地的16位数值组成的。这个16位数值称为端口，所以一共有2^16 ＝ 65535个端口可用。

1024以下的（不0包括1024）的端口被保留，只能用作由特权用户（比如UNIX系统的 root）启动的标准服务，这些端口称为`知名端口`。一些知名的端口如下：

|端口|协议|用途|
|---|---|---|
|20，21| FTP | 文件传输协议，21是控制端口，20是数据端口|
|22| SSH | 远程登录，Telnet的替代|
|23| Telnet | TELNET 终端仿真服务 |
|25| SMTP |简单邮件传输协议|
|53| DNS | 域名解析服务|
|80| HTTP| 万维网, 超文本传输服务|
|443| HTTPS| 安全的 Web|

1024～49151 之间的的其它端口可以通过 IANA 注册，由非特权用户使用，但是应用程序可以选择自己的端口号。

### 网络套接字

网络上不同的计算机之间进行 TCP、UDP通信需要使用网络套接字（socket）。socket是在不同计算机之间进行通信的一个抽象。他工作于TCP/IP协议中应用层和传输层之间的一个抽象。

![][2]

socket起源于UNIX，在Unix`一切皆文件`哲学的思想下，socket是一种"打开—读/写—关闭"模式的实现，服务器和客户端各自维护一个"文件"，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。

详细内容参见 [Socket](Socket.md)

## TCP，UDP区别

TCP协议和UDP协议特性区别，主要从连接性、可靠性、有序性、拥塞控制、传输速度、头部大小(Header size)等6个方面来讲。

1. TCP是面向连接的协议，UDP是无连接协议。TCP用三次握手建立连接，UDP发送数据前不需要建立连接；
2. TCP可靠，UDP不可靠。TCP丢包会重传，并且有确认机制，UDP不会；
3. TCP有序，UDP无序。消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会；
4. TCP 必须对数据进行校验，而UDP的校验是可选的；
5. TCP有流量控制（滑动窗口）和拥塞控制，UDP没有；
6. TCP传输慢，UDP传输快。因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。
7. TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，包头比较大（TCP头部至少需要20字节，UDP头部只要8个字节）。

基于TCP的协议有：HTTP/HTTPS，Telnet，FTP，SMTP。
基于UDP的协议有：DHCP，DNS，SNMP，TFTP，BOOTP。

# 应用层

## HTTP 协议

HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80），我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像，我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。

HTTP是一个`无状态`的协议，也就是说服务器不会去维护与客户交互的相关信息，因此它对于事务处理没有记忆能力。为了解决HTTP无状态的问题，HTTP 引入了 Cookie 和 Session机制，用来保存客户端状态信息。

HTTP协议中，并没有规定它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输，因此，任何能够提供这种保证的协议都可以被其使用，在TCP/IP协议族使用TCP作为其传输层。

HTTP 有两个主要的版本 HTTP 1.0 和 HTTP 1.1，1.1 版本在带宽优化，长连接，缓存，Host头域，错误提示等方面有一些改进。

详细内容参见 [HTTP](HTTP.md)

# 其它

[Questions](Questions.md) 里面是一些和网络场景有关的具体问题，比如：

* 访问网页过程
* Ping 过程
* QQ 传输层 UDP

[More](More.md) 里面是一些网络方面的零散概念，比如：

* 网络延迟 
* 以太网工作模式
* 路由权
* 路由器与交换机区别

# 更多阅读

[协议森林系列文章](http://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html)  
[《计算机网络》这门课为何如此之难？](https://www.zhihu.com/question/19718686)    
[TCP和UDP的区别](http://liangjiabin.com/blog/2015/03/difference-between-tcp-vs-udp-protocol.html)

[1]: http://7xrlu9.com1.z0.glb.clouddn.com/Network_01.png
[2]: http://7xrlu9.com1.z0.glb.clouddn.com/Network_02.jpg





